./PaxHeader/tokenTypes.java000644 000765 000024 00000000036 13723447547 020707 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1598967655.331597306
./tokenTypes.java000644 000765 000024 00000000214 13723447547 016734 0ustar00nadavsmacbookprostaff000000 000000 /**
 * enum class for different token types
 */
public enum tokenTypes {
    keyword, symbol, identifier, integerConstant, stringConstant
}
./PaxHeader/README000644 000765 000024 00000000036 13723450634 016546 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1598968220.542939681
./README000644 000765 000024 00000001467 13723450634 014606 0ustar00nadavsmacbookprostaff000000 000000 nadav.alali, amitchen93
===============================================================================
Nadav Alali, ID 313549206, nadav.alali@mail.huji.ac.il
Amit Chen, ID 308162502, amit.henhanina@mail.huji.ac.il
===============================================================================

                           Project 10 - An java File
                           ----------------------- 
  

Submitted Files
---------------
README - This file.
Makefile - for execute our java program
JackAnalyzer.java - the execute file
CompilationEngine.java -  class thst makes the compilation process
JackDictionary.java - an interface dictionary for holds data from input file
JackTokenizer.java - Tokenizer class of jack
keyWords.java - Enum class for key Words
tokenTypes - Enum class for token types


Remarks
-------

./PaxHeader/Makefile000644 000765 000024 00000000036 13723450633 017325 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1598968219.213227506
./Makefile000644 000765 000024 00000001437 13723450633 015362 0ustar00nadavsmacbookprostaff000000 000000 ###############################################################################
#
# Makefile for a Java project
#
###############################################################################

# **** Beginning of the actual Makefile ****
# The following line is a declaration of a variable named JAVAC:
JAVAC=javac

JAVACFLAGS=-encoding ISO-8859-1

SRCS=*.java

# The EXEC variable should include the name of the run file executable only.
EXEC=JackAnalyzer

# Let's define more variables that we'll use later on:
TAR=tar
TARFLAGS=cvf
TARNAME=project10.tar
TARSRCS=$(SRCS) $(EXEC) README Makefile

# The "all" rule is what runs when you call "make":
all: compile

compile:
	$(JAVAC) $(JAVACFLAGS) $(SRCS)
	chmod +x $(EXEC)

tar:
	$(TAR) $(TARFLAGS) $(TARNAME) $(TARSRCS)

clean:
	rm -f *.class *~

./PaxHeader/keyWords.java000644 000765 000024 00000000036 13723447547 020351 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1598967655.328271666
./keyWords.java000644 000765 000024 00000000327 13723447547 016403 0ustar00nadavsmacbookprostaff000000 000000 /**
 * enums for different keywords
 */
public enum keyWords {
    CLASS, method, function, constructor, INT, BOOLEAN, CHAR, VOID, VAR, STATIC, FIELD, LET, DO, IF, ELSE, WHILE,
    RETURN, TRUE, FALSE, NULL, THIS
}
./PaxHeader/JackTokenizer.java000644 000765 000024 00000000036 13723706016 021272 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1599048718.223168699
./JackTokenizer.java000644 000765 000024 00000016311 13723706016 017324 0ustar00nadavsmacbookprostaff000000 000000 import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Removes all comments and white space from the input stream and breaks it into Jacklanguage
 * tokens, as specified by the Jack grammar.
 */
public class JackTokenizer implements JackDictionary{
    private Scanner _inputScanner; // scanner for the file
    private ArrayList<String> _currLineDivided; // array which contains the curr line tokens
    private int _currPosition; // curr position  in the "_currLineDivided"

    /**
     * Opens the input file/stream and gets ready to tokenize it
     * @param inputFile
     * @throws FileNotFoundException
     */
    public JackTokenizer(File inputFile) throws FileNotFoundException {
        _inputScanner = new Scanner(inputFile);
        _currLineDivided = new ArrayList<>();
        _currPosition = 0;
    }

    /**
     * do we have more tokens in the input?
     * @return - true if we have more tokens, otherwise false.
     */
    public boolean hasMoreTokens() {
        if (_currPosition >= _currLineDivided.size() - 1)
            return _inputScanner.hasNext();
        return true;
    }

    /**
     * gets the next token from the input and makes it the current token.
     * This method should only be called if hasMoreTokens() is true. Initially there is no current token.
     */
    public void advance() {
        _currPosition++;
        if (_currPosition >= _currLineDivided.size())
            cleanLine(_inputScanner.nextLine());
    }

    /**
     *
     * @return - returns the type of the current token.
     */
    public tokenTypes tokenType(){
        // return if the line is empty
        if (_currLineDivided.isEmpty())
            return null;

        return returnType(_currLineDivided.get(_currPosition));
    }

    /**
     *
     * @return - returns the keyword which is the current token. Should be called only when tokenType() is KEYWORD.
     */
    public keyWords keyWord(){ return keywordMap.get(_currLineDivided.get(_currPosition)); }

    /**
     *
     * @return - returns the character which is the current token. Should be called only when tokenType() is SYMBOL.
     */
    public char symbol() { return _currLineDivided.get(_currPosition).charAt(0); }

    /**
     *
     * @return - returns the identifier which is the current token. Should be called only when tokenType() is IDENTIFIER
     */
    public String identifier() { return _currLineDivided.get(_currPosition); }

    /**
     *
     * @return - returns the integer value of the current token. Should be called only when tokenType() is INT_CONST
     */
    public int intVal() { return Integer.parseInt(_currLineDivided.get(_currPosition )); }

    /**
     *
     * @return - returns the string value of the current token, without the double quotes.
     * Should be called only when tokenType() is STRING_CONST.
     */
    public String stringVal() {
        String str = _currLineDivided.get(_currPosition);
        return str.replaceAll("\"", "");
    }


    /**
     * cleans a line from spaces and comments
     * also, divides the line by tokens into the "_currLineDivided" array
     * @param line - line to clean
     */
    private void cleanLine(String line)
    {
        _currLineDivided.clear(); // clear previous line
        _currPosition = 0;
       String cleanedLine = line;

       // remove comments
       if (isComment(line))
           cleanedLine = handleComments(cleanedLine);

        // separate line between comments
        Pattern pattern = Pattern.compile("(\".*\")|([^\"]+)");
        Matcher matcher = pattern.matcher(cleanedLine);

        while (matcher.find())
        {
            if (matcher.group(1) != null)
                _currLineDivided.add(matcher.group(1));
            else
            {
                // clean line from spaces
                String tmp = matcher.group(2).replaceAll("\\s+", " ");
                // command shouldn't start with a white space
                if (tmp.length() > 0 && tmp.charAt(0) == ' ')
                    tmp = tmp.substring(1);
                parseLine(tmp);
            }
        }
    }

    /**
     * clean line from comments of type '*'
     * @param line - line to clean
     * @return - line without comments
     */
    private String cleanCommentLine(String line){
        while (!line.contains("*/"))
        {
            line = _inputScanner.nextLine();
        }
        return _inputScanner.nextLine();
    }

    /**
     * from line to tokens
     * @param line - line to parse
     */
    private void parseLine(String line)
    {
        String[] noSpaces = line.split(" ");
        for (String str : noSpaces)
        {
            int currPosition = 0;
            for (int i = 0; i < str.length(); i++)
            {

                if (symbols.contains(str.charAt(i)))
                {
                    if (currPosition != i)
                        _currLineDivided.add(str.substring(currPosition, i));
                    _currLineDivided.add("" + str.charAt(i));
                    currPosition = i + 1;
                }
            }
            // copy the rest
            if (!str.substring(currPosition).isEmpty())
                _currLineDivided.add(str.substring(currPosition));
        }
    }

    /**
     * gets the curr token
     * @return
     */
    String getToken() { return _currLineDivided.get(_currPosition); }


    /**
     *
     * @param token - token to check
     * @return - the type of the curr token
     */
    private tokenTypes returnType(String token){
        if (token.length() == 1 && symbols.contains(token.charAt(0)) )
            return tokenTypes.symbol;

        else if (keywordMap.containsKey(token))
            return tokenTypes.keyword;

            // if const integer
        else if (token.matches("\\d+"))
            return tokenTypes.integerConstant;

            // if const string
        else if (token.matches("\".*\""))
            return tokenTypes.stringConstant;

        // else identifier
        return tokenTypes.identifier;
    }

    /**
     *
     * @param line - line to clean from comments
     * @return - a line without comments
     */
    private String handleComments(String line){
        if (line.contains("/*")) {
            while (line.contains("/*")) {
                int index = line.indexOf("/*");
                line = line.substring(0, index) + cleanCommentLine(line.substring(index));
            }
        }
        // clean from comment
        int commentIndex = line.indexOf("//");
        if (commentIndex != -1)
            line = line.substring(0, commentIndex);
        return line;
    }

    /**
     *
     * @param line - line to check
     * @return - true if there is a comment in the curr line, otherwise false.
     */
    private boolean isComment(String line){
        int commentIndex = line.indexOf("/*");
        commentIndex = (commentIndex == -1) ? line.indexOf("//") : commentIndex;

        if (commentIndex == -1)
            return false;

        int stringIndex = line.indexOf("\"");
        if (stringIndex > commentIndex)
            return true;
        stringIndex += line.substring(stringIndex + 1).indexOf("\"");
        return stringIndex < commentIndex;
    }
}
./PaxHeader/JackDictionary.java000644 000765 000024 00000000036 13723706016 021425 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1599048718.218597385
./JackDictionary.java000644 000765 000024 00000002422 13723706016 017455 0ustar00nadavsmacbookprostaff000000 000000 import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

/**
 * dictionary for different tokens
 */
public interface JackDictionary {
    // keywords map
    Map<String, keyWords> keywordMap = new HashMap<>(){
        {
            // keywords
            put("class", keyWords.CLASS); put("constructor", keyWords.constructor); put("function", keyWords.function);
            put("method", keyWords.method); put("field", keyWords.FIELD); put("static", keyWords.STATIC);
            put("var", keyWords.VAR); put("int", keyWords.INT); put("char", keyWords.CHAR);
            put("boolean", keyWords.BOOLEAN); put("void", keyWords.VOID); put("true", keyWords.TRUE);
            put("false", keyWords.FALSE); put("null", keyWords.NULL); put("this", keyWords.THIS);
            put("let", keyWords.LET); put("do", keyWords.DO); put("if", keyWords.IF);
            put("else", keyWords.ELSE); put("while", keyWords.WHILE); put("return", keyWords.RETURN);
        }
    };

    // symbols map
    HashSet<Character> symbols = new HashSet<>(){
        {
            add('{'); add('}'); add('('); add(')'); add('['); add(']'); add('.'); add(','); add(';'); add('+'); add('-');
            add('*'); add('/'); add('&'); add('|'); add('<'); add('>'); add('='); add('~');
        }
    };
}
./PaxHeader/JackAnalyzer.java000644 000765 000024 00000000036 13723706016 021105 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1599048718.215491447
./JackAnalyzer.java000644 000765 000024 00000001777 13723706016 017151 0ustar00nadavsmacbookprostaff000000 000000 import java.io.File;
import java.io.FileNotFoundException;
import java.util.Objects;


/**
 * execution class
 */
public class JackAnalyzer {
    public static void main (String[] args) throws FileNotFoundException {
        File inputFile = new File(args[0]);
        if (inputFile.isFile())
            translate(inputFile);
        else {
            for (File file : Objects.requireNonNull(inputFile.listFiles())){
                if (file.getName().contains(".jack")) // translate only jack files
                    translate(file);
            }
        }

    }

    /**
     * will translate a jack file.
     * @param inputFile - file to translate
     * @throws FileNotFoundException
     */
    private static void translate(File inputFile) throws FileNotFoundException {
        File outputFile = new File(inputFile.getAbsolutePath().replaceAll("\\.jack", "\\.xml"));
        CompilationEngine compilationEngine = new CompilationEngine(inputFile, outputFile);
        compilationEngine.CompileClass();
    }
}
./PaxHeader/JackAnalyzer000644 000765 000024 00000000036 13723455077 020175 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1598970431.870732007
./JackAnalyzer000644 000765 000024 00000002117 13723455077 016226 0ustar00nadavsmacbookprostaff000000 000000 # **** Why do we need this file? ****
# The purpose of this file is to run your project.
# We want our users to have a simple API to run the Assembler, no matter the language
# it was written in. So, we need a "wrapper" that will hide all language-specific details to do so,
# thus enabling our users to simply type 'Assembler <path>' in order to use it.

# **** What are '#!/bin/sh' and '$*'? ****
# '$*' is a variable that holds all the arguments this file has received. So, if you
# run "Assembler-java trout mask replica", $* will hold "trout mask replica".

# **** What should I change in this file to make it work with my project? ****
# IMPORTANT 1: The only two lines the file should contain are '#!/bin/sh' (which means that this file is a 
# 			   script) and the command you use to run your project.
# IMPORTANT 1: For this file to run when you call "Assembler", rename it from "Assembler-java" to "Assembler".
# IMPORTANT 2: This file assumes that the main is contained in "Main.java".
#			   If your main is contained elsewhere, you will need to change this.

#!/bin/sh
java JackAnalyzer $*./PaxHeader/CompilationEngine.java000644 000765 000024 00000000036 13723706016 022133 xustar00nadavsmacbookprostaff000000 000000 30 mtime=1599048718.211798622
./CompilationEngine.java000644 000765 000024 00000035626 13723706016 020177 0ustar00nadavsmacbookprostaff000000 000000 import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.HashSet;

/**
 * This module effects the actual compilation into XML form.
 * It gets its input from a JackTokenizer and writes its parsed XML structure into an output file/stream.
 * This is done by a series of compilexxx() methods, where xxx is a corresponding syntactic element of the Jack grammar.
 * The contract between these methods is that each compilexxx() method should read the syntactic construct xxx from the
 * input, advance() the tokenizer exactly beyond xxx, and output the XML parsing of xxx.
 * Thus, compilexxx()may only be called if indeed xxx is the next syntactic element of the input.
 */
public class CompilationEngine implements JackDictionary {
    private static HashSet<String> keywordConstant = new HashSet<>() {{add("true"); add("false"); add("null"); add("this");}};
    private static HashSet<Character> unaryOp = new HashSet<>() {{add('-'); add('~');}};
    private static HashSet<Character> op = new HashSet<>() {{add('+'); add('-'); add('*'); add('/'); add('&'); add('|');
                                                          add('<'); add('>'); add('=');}};
    private JackTokenizer _jackTokenizer;
    private PrintWriter _printWriter;
    private int _numOfTabs;

    /**
     * creates a new compilation engine with the given input and output. The next method called must be compileClass().
     * @param inputFile
     * @param outputFile
     * @throws FileNotFoundException
     */
    public CompilationEngine(File inputFile, File outputFile) throws FileNotFoundException {
        _jackTokenizer = new JackTokenizer(inputFile);
        advance();
        _printWriter = new PrintWriter(outputFile);
        //_printWriter = new PrintWriter(System.out);
        _numOfTabs = 0;
    }

    /**
     * compiles a complete class.
     */
    public void CompileClass(){
        // initialize class
        writeTabs();
        writeToken("class", false, true);
        _numOfTabs++;
        for (int i = 0; i < 3; i++) // initialize 'class' + 'name' + '{'
        {
            writeCommand();
            advance();
        }
        // initialize field/static vars
        CompileClassVarDec();

        //subroutine call
        CompileSubroutine();

        writeCommand(); advance(); // write '}'
        _numOfTabs--;
        writeTabs();
        writeToken("class", true, true);
        _printWriter.close();
    }

    /**
     * compiles a static declaration or a field declaration.
     */
    public void CompileClassVarDec()
    {
        VarDec("classVarDec");
    }

    private void VarDec(String type){
        while (_jackTokenizer.tokenType() == tokenTypes.keyword &&
                (_jackTokenizer.keyWord() == keyWords.STATIC || _jackTokenizer.keyWord() == keyWords.FIELD
                        || _jackTokenizer.keyWord() == keyWords.VAR))
        {
            writeTabs();
            writeToken(type, false, true);
            _numOfTabs++;
            CompileVarDec();
            _numOfTabs--;
            writeTabs();
            writeToken(type, true, true);
        }
    }

    /**
     * compiles a var declaration.
     */
    public void CompileVarDec()
    {
        while (!(_jackTokenizer.tokenType() == tokenTypes.symbol && _jackTokenizer.symbol() == ';'))
        {
            writeCommand();
            advance();
        }
        // write ';'
        writeCommand();
        advance();
    }

    /**
     * compiles a complete method, function, or constructor.
     */
    public void CompileSubroutine(){
        while (_jackTokenizer.tokenType() == tokenTypes.keyword &&
                (_jackTokenizer.keyWord() == keyWords.constructor || _jackTokenizer.keyWord() == keyWords.function
                        || _jackTokenizer.keyWord() == keyWords.method)) {
            writeTabs();
            writeToken("subroutineDec", false, true);
            _numOfTabs++;
            subroutine();
            _numOfTabs--;
            writeTabs();
            writeToken("subroutineDec", true, true);
        }
    }

    /**
     * compiles subroutine
     */
    private void subroutine()
    {
        for (int i = 0; i < 4; i++) // ('constructor' | 'function' | 'method') ('void' | type) subroutineName '('
        {
            writeCommand();
           advance();
        }
        // write param list
        compileParameterList();
        writeCommand(); advance();// write ')'
        subroutineBody();
    }

    /**
     * compiles subroutineBody
     */
    private void subroutineBody(){
        writeTabs();
        writeToken("subroutineBody", false, true);
        _numOfTabs++;
        writeCommand(); advance(); // write '{'
        VarDec("varDec");
        compileStatements();
        _numOfTabs--;
        writeTabs();
        writeToken("subroutineBody", true, true);
    }

    /**
     * compiles a (possibly empty) parameter list, not including the enclosing “()”.
     */
    public void compileParameterList()
    {
        writeTabs();
        writeToken("parameterList", false, true);
        _numOfTabs++;
        while (!(_jackTokenizer.tokenType() == tokenTypes.symbol && _jackTokenizer.symbol() == ')'))
        {
            writeCommand();
            advance();
        }
        _numOfTabs--;
        writeTabs();
        writeToken("parameterList", true, true);
    }

    /**
     * compiles a sequence of statements, not
     * including the enclosing “{}”.
     */
    public void compileStatements(){
        writeTabs();
        writeToken("statements", false, true);
        _numOfTabs++;
        boolean flag = true;
        while (flag && _jackTokenizer.tokenType() == tokenTypes.keyword)
        {
            keyWords key = _jackTokenizer.keyWord();
            switch (key){
                case IF:
                    compileIf();
                    break;
                case DO:
                    compileDo();
                    break;
                case LET:
                    compileLet();
                    break;
                case WHILE:
                    compileWhile();
                    break;
                case RETURN:
                    compileReturn();
                    break;
                default:
                    flag = false;
                    break;
            }
        }

        _numOfTabs--;
        writeTabs();
        writeToken("statements", true, true);
        writeCommand(); advance(); // write '}'
    }

    /**
     * Compiles a do statement
     */
    public void compileDo(){
        writeTabs();
        writeToken("doStatement", false, true);
        _numOfTabs++;
        writeCommand(); advance(); // write 'do'
        writeCommand(); advance(); // some name
        if (_jackTokenizer.tokenType() == tokenTypes.symbol && _jackTokenizer.symbol() == '.') {
            writeCommand();
            advance();
            writeCommand();
            advance(); // some subroutineName
        }
        writeCommand();advance(); // write '('
        CompileExpressionList();
        writeCommand();advance(); // write ')'
        writeCommand();advance(); // write ';'
        _numOfTabs--;
        writeTabs();
        writeToken("doStatement", true, true);
    }

    /**
     * Compiles a let call
     */
    public void compileLet(){
        writeTabs();
        writeToken("letStatement", false, true);
        _numOfTabs++;
        writeCommand(); advance(); // write 'let'
        writeCommand(); advance(); // write 'varName'
        writeCommand(); advance(); // write '='
        CompileExpression();
        writeCommand(); advance();
        if (_jackTokenizer.tokenType() == tokenTypes.symbol && _jackTokenizer.symbol() == '=')
        {
            writeCommand(); advance(); // write '='
            CompileExpression();
            writeCommand(); advance();
        }
        _numOfTabs--;
        writeTabs();
        writeToken("letStatement", true, true);
    }

    /**
     * compiles if statement
     */
    public void compileIf(){
        writeTabs();
        writeToken("ifStatement", false, true);
        _numOfTabs++;
        writeCommand(); advance(); // write 'if'
        writeCommand(); advance(); // write '('
        CompileExpression();
        writeCommand(); advance(); // write ')'
        writeCommand(); advance(); // write '{'
        compileStatements();
        if (_jackTokenizer.tokenType() == tokenTypes.keyword && _jackTokenizer.keyWord() == keyWords.ELSE)
        {
            writeCommand(); advance();// write 'else'
            writeCommand(); advance();// write '{'
            compileStatements();
        }

        _numOfTabs--;
        writeTabs();
        writeToken("ifStatement", true, true);
    }

    /**
     * Compiles a while call
     */
    public void compileWhile(){
        writeTabs();
        writeToken("whileStatement", false, true);
        _numOfTabs++;
        writeCommand(); advance(); // write 'while'
        writeCommand(); advance(); // write '('
        CompileExpression();
        writeCommand(); advance(); // write ')'
        writeCommand(); advance(); // write '{'
        compileStatements();
        //writeCommand(); advance(); // write '}'
        _numOfTabs--;
        writeTabs();
        writeToken("whileStatement", true, true);
    }

    /**
     * compiles an expression.
     */
    public void CompileExpression(){
        writeTabs();
        writeToken("expression", false, true);
        _numOfTabs++;
        recursiveExpression();
        _numOfTabs--;
        writeTabs();
        writeToken("expression", true, true);
    }

    /**
     * call expression recursively
     */
    private void recursiveExpression(){
        compileTerm();
        if (_jackTokenizer.tokenType() == tokenTypes.symbol
                && (_jackTokenizer.symbol() == ')' || _jackTokenizer.symbol() == ']' || _jackTokenizer.symbol() == ';'
                   || _jackTokenizer.symbol() == ','))
            return;
        if (op.contains(_jackTokenizer.getToken().charAt(0))) {
            writeCommand();
            advance(); // write op
        }

        recursiveExpression();
    }

    /**
     * compiles term
     */
    public void compileTerm() {
        writeTabs();
        writeToken("term", false, true);
        _numOfTabs++;

        String token = _jackTokenizer.getToken();
        tokenTypes tokenType = _jackTokenizer.tokenType();

        if (tokenType == tokenTypes.identifier){
            writeCommand(); advance();
            token = _jackTokenizer.getToken();
            if (token.charAt(0) == '.'){
                writeCommand(); advance();
                writeCommand(); advance();
            }
            token = _jackTokenizer.getToken();
            if (token.charAt(0) == '(') {
                writeCommand(); advance();
                CompileExpressionList();
                writeCommand(); advance();
            }
            else if (token.charAt(0) == '[') {
                writeCommand(); advance();
                CompileExpression();
                writeCommand(); advance();
            }
        }
        else if (keywordConstant.contains(token)|| tokenType == tokenTypes.stringConstant ||
                tokenType == tokenTypes.integerConstant){

                writeCommand();
                advance();
        }
        else if (unaryOp.contains(token.charAt(0))){
            writeCommand();advance();
            compileTerm();
        }
        else if (token.charAt(0) == '('){
            writeCommand();advance();
            CompileExpression();
            writeCommand();advance();
        }

        _numOfTabs--;
        writeTabs();
        writeToken("term", true, true);
    }


    /**
     * compiles an expression list.
     */
    public void CompileExpressionList(){
        writeTabs();
        writeToken("expressionList", false, true);
        _numOfTabs++;

        if (_jackTokenizer.getToken().charAt(0) != ')')
            CompileExpression();
        while (_jackTokenizer.getToken().charAt(0) == ',')
        {
            writeCommand();advance(); // write ','
            CompileExpression();
        }

        _numOfTabs--;
        writeTabs();
        writeToken("expressionList", true, true);
    }

    /**
     * compiles a return statement.
     */
    public void compileReturn(){
        writeTabs();
        writeToken("returnStatement", false, true);
        _numOfTabs++;
        writeCommand();
        advance();
        if (!(_jackTokenizer.tokenType() == tokenTypes.symbol && _jackTokenizer.symbol() == ';'))
            CompileExpression();
        writeCommand();advance();
        _numOfTabs--;
        writeTabs();
        writeToken("returnStatement", true, true);
    }

    /**
     * helper func that writes a token
     * @param token - token to write
     * @param isClose - should we close the token or not?
     * @param newLine - should we add a new line or not?
     */
    private void writeToken(String token, boolean isClose, boolean newLine){
        String close = isClose ? "/" : "";
        String nLine = newLine ? "\n" : "";
        _printWriter.print("<" + close + token + ">" + nLine);
    }

    /**
     * write tabs so the output will be organized
     */
    private void writeTabs(){
        for (int i = 0; i < _numOfTabs; i++)
            _printWriter.print("  ");
    }

    /**
     * writes a command based on the curr token
     */
    private void writeCommand()
    {
        // write tabs
        writeTabs();
        tokenTypes type = _jackTokenizer.tokenType();
        if (type == null)
            return;
        writeToken(type.toString(), false, false);
        _printWriter.print(" ");
        switch (type)
        {
            case symbol:
                char symbol = _jackTokenizer.symbol();
                if (symbol == '<')
                    _printWriter.print("&lt;");
                else if (symbol == '>')
                    _printWriter.print("&gt;");
                else if (symbol == '&')
                    _printWriter.print("&amp;");
                else if (symbol == '\"')
                    _printWriter.print("&quot;");
                else
                    _printWriter.print(symbol);
                break;
            case identifier:
                _printWriter.print(_jackTokenizer.identifier());
                break;
            case keyword:
                _printWriter.print(_jackTokenizer.keyWord().toString().toLowerCase());
                break;
            case stringConstant:
                _printWriter.print(_jackTokenizer.stringVal());
                break;
            case integerConstant:
                _printWriter.print(_jackTokenizer.intVal());
                break;
            default:
                return;
        }
        _printWriter.print(" ");
        writeToken(type.toString(), true, true);
    }

    /**
     * a func that advances to the next token
     */
    private void advance(){
        if (_jackTokenizer.hasMoreTokens())
            _jackTokenizer.advance();
        while (_jackTokenizer.tokenType() == null && _jackTokenizer.hasMoreTokens())
            _jackTokenizer.advance();
    }
}
